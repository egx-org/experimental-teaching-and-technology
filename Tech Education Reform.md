# Tech Education Reform

Current status: **DRAFT**

Thoughts about the structural deficiencies in our current educational system and how the mismatch with the needs of technology and knowledge sector jobs makes school more of a liability than an asset in the real world.

## Tech is About Synthesis

Programming and most tech tasks require the evaluation, integration and synthesis of ideas and concepts from multiple discplines. (See also: Bloom's taxonomy)

In education, subjects are typically broken apart into discrete subject areas. There is also a heavy emphasis on memorization and on a single interpretation of a concept. While this makes for easy and efficient measurement, it encourages a very weak and artificial mode of working that is unsuibable for knowledge sector jobs.

## Memorization is a Waste of Time

Anything you actually need to remember will generally stick after you've had to look it up a few times. Most memorization in school is more beneficial toward optimizing for evaluation (passing the test) than it is for actual learning and problem solving.

## Collaboration

Collaboration is critical in tech work. There is no non-trivial job that will be preformed by an individual. The vast majority of dev work will be done in 2-8 person teams. Larger projects will be composed of multiple small teams collaborating.

Collaboration is also critical to deal with the non-linearity of programming. Everyone gets stuck at some point, and it's usually not in the same place. Having people to ask or even just explain the issue to is often the best way to get unstuck.

## Exploration and Evaluation

Students are not particularly good at evaluating large collections of information. Programmers routinely face large piles of information e.g. which library do I use to parse JSON in this project? Choosing wrong can be very costly on the order of hours to days of lost time on a bad choice. Worst case, the choice is not corrected and the software is built up around it for years. In these cases a complete rewrite may be the only way to correct the issue which can cost months to years.

## Focus and Flow State

Constant switching between tasks and environments nearly guarantees that students will never enter flow state in traditional classrooms.

In the real world flow state is essential to productive programming.

## Laziness and Efficiency

Watching introductory level programming students or non-programmers in general is an excercise in frustration for professional programmers. Human computer interaction for such novices is slow and astoundingly inefficient. Worse, the convenience features (auto tag balancing) become impediments.

Professional programmers spend tremendous amounts of time customizing their systems to improve their efficiency and make their work easier.

Pointing out improvements in workflows to programmers will lead to thanks and/or discussions about the merits of various approaches. Doing the same with non-programmers will often be meet with hostility.

While it may seem ridiculous to spend considerable amounts of time automating "trivial" tasks e.g. 3 hours making a script to complete a 10 minute task. This ridiculousness is an artefact of failing to understand scaling factors in knowledge work.

1. Consistency and repeatability
2. Long term time savings
3. Time savings for others
4. Enabling the handling of extremely large data sets (see also error reduction regarding data loss in Excel)

## Classroom Management

The need for extensive classroom management strategies stems in large part from the lack of agency students have and their perception (often correct) of the lack of utility of that which they are being taught.

When students are given agency and control over their projects, "classroom management" is rarely necessary. Note that the best hackathons tend toward self-managed groups of individuals working toward a comman goal on a shared project.

## Late vs Good

Punctuality is critically important in some jobs e.g. surgeon, firefighter, military, assembly line worker.

In tech however, punctuality is a distant concern compared to quality. Bad code costs lives and trillions of dollars globally. It's far more important for code to be correct, clean, and maintainable than for it to be done on time.

There are exceptions where getting things done quickly matters like while responding to an incident, restoring critical services during an outage, or preparing systems for launch windows in aerospace. Though these are (or sholud be) rare occurances with regard to all tech jobs.
